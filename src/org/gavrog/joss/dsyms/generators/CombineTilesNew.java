/*
   Copyright 2008 Olaf Delgado-Friedrichs

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


package org.gavrog.joss.dsyms.generators;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.gavrog.box.collections.Pair;
import org.gavrog.box.collections.Partition;
import org.gavrog.joss.algorithms.BranchAndCut;
import org.gavrog.joss.dsyms.basic.DSMorphism;
import org.gavrog.joss.dsyms.basic.DSPair;
import org.gavrog.joss.dsyms.basic.DSymbol;
import org.gavrog.joss.dsyms.basic.DelaneySymbol;
import org.gavrog.joss.dsyms.basic.DynamicDSymbol;
import org.gavrog.joss.dsyms.basic.IndexList;
import org.gavrog.joss.dsyms.basic.Subsymbol;
import org.gavrog.joss.dsyms.basic.Traversal;

/**
 * @author Olaf Delgado
 * @version $Id:$
 */
public class CombineTilesNew extends BranchAndCut<DSymbol> {
    // --- the input symbol
    final DelaneySymbol original;

    // --- precomputed or extracted data used by the algorithm
    final private int dim;
    final private List<List<DSymbol>> componentTypes;
    
    // --- persistent data used and generated by elementSignatures()
    final private Map<List, Integer> invarToIndex = new HashMap<List, Integer>();
    final private List<Map> indexToRepMap = new ArrayList<Map>();

    // --- the current state
    private final DynamicDSymbol current;
    private final int unused[];

    // --- auxiliary information applying to the current state
    private int size;
    private Map<Object, Pair> signatures;

    /**
     * The instances of this class represent individual moves of setting
     * d-neighbor values. These become the entries of the trial stack.
     */
    protected class CMove implements Move{
        final public Object element;
        final public Object neighbor;
        final public int newType;
        final public int newForm;

        public CMove(final Object element, final Object neighbor, int newType,
				int newForm) {
            this.element = element;
            this.neighbor = neighbor;
            this.newType = newType;
            this.newForm = newForm;
        }

        @Override
		public String toString() {
			return String.format("(%s, %s, %d, %d, %s, %d)", element,
					neighbor, newType, newForm);
		}
    }

    /**
     * Creates a new instance.
     * 
     * @param ds the symbol to extend.
     */
    public CombineTilesNew(final DelaneySymbol ds) {
        this.dim = ds.dim() + 1;

        // --- basic checks on the input symbol
        if (ds == null) {
            throw new IllegalArgumentException("null argument");
        }
        try {
            ds.size();
        } catch (UnsupportedOperationException ex) {
            throw new UnsupportedOperationException("symbol must be finite");
        }
        if (!ds.isComplete()) {
            throw new UnsupportedOperationException("symbol must be complete");
        }
        
        // --- now check the connected components of the input symbol
        final List idcs = new IndexList(ds);
        for (final Iterator orbs = ds.orbitReps(idcs); orbs.hasNext();) {
            final DelaneySymbol sub = new Subsymbol(ds, idcs, orbs.next());
            if (this.dim == 3 && !sub.isSpherical2D()) {
                throw new IllegalArgumentException(
                        "components must be spherical");
            }
        }

        // --- remember the input symbol
        this.original = ds;

        // --- collect component types with multiplicities and the different
        //     forms they can appear in within a generated symbol
        final DSymbol canonical = (DSymbol) ds.canonical();
        final Map<DelaneySymbol, Integer> multiplicities =
        	componentMultiplicities(canonical);
        final List<DelaneySymbol> types =
        	new ArrayList<DelaneySymbol>(multiplicities.keySet());
        Collections.sort(types);
        final List<List<DSymbol>> forms = new ArrayList<List<DSymbol>>();
        final List<Integer> free = new ArrayList<Integer>();
        for (int i = 0; i < types.size(); ++i) {
            final DelaneySymbol type = types.get(i);
            forms.add(Collections.unmodifiableList(subCanonicalForms(type)));
            free.add(multiplicities.get(type));
            log("# " + free.get(i) + " copies and " + forms.get(i).size()
					+ " forms for " + type + " with invariant "
					+ type.invariant() + "\n");
        }
        this.componentTypes = Collections.unmodifiableList(forms);

        // --- initialize the state
        this.size = 0;
        this.signatures = new HashMap<Object, Pair>();
        this.unused = new int[free.size()];
        for (int i = 0; i < free.size(); ++i) {
        	this.unused[i] = free.get(i);
        }
        this.current = new DynamicDSymbol(this.dim);

        // --- add the component with the smallest invariant
        final DSymbol start = this.componentTypes.get(0).get(0);
        this.current.append((DSymbol) start.canonical()); //MUST make canonical!
        this.unused[0] -= 1;
        this.size = this.current.size();
        this.signatures = elementSignatures(this.current, this.dim - 2);
    }

    /**
     * Computes signatures for the elements of symbol.
     * 
     * @param ds the symbol to compute signatures for.
     * @param dim
     * @return a map assigning signatures to the symbol's elements.
     */
    public Map<Object, Pair> elementSignatures(final DelaneySymbol ds,
			final int dim) {
        final Map<Object, Pair> signatures = new HashMap<Object, Pair>();
        final List<Integer> idcs = new ArrayList<Integer>();
        for (int i = 0; i <= dim; ++i) {
            idcs.add(i);
        }

        for (final Iterator reps = ds.orbitReps(idcs); reps.hasNext();) {
            final Object D = reps.next();
            final DelaneySymbol face = new Subsymbol(ds, idcs, D);
            final List invariant = face.invariant();
            if (!this.invarToIndex.containsKey(invariant)) {
                final int i = this.indexToRepMap.size();
                this.invarToIndex.put(invariant, i);
                final DSymbol canon = (DSymbol) face.canonical();
                this.indexToRepMap.add(mapToFirstRepresentatives(canon));
            }
            final Integer i = this.invarToIndex.get(invariant);
            final Map toRep = this.indexToRepMap.get(i);
            final Map toCanon = face.getMapToCanonical();
            for (final Iterator iter = face.elements(); iter.hasNext();) {
                final Object E = iter.next();
                final Object rep = toRep.get(toCanon.get(E));
                signatures.put(E, new Pair(i, rep));
            }
        }

        return signatures;
    }

    /**
     * Collects the isomorphism types of connected components of a symbol and
     * counts how many times each type occurs. The result is a map with
     * {@link DSymbol} instances as its keys and the associated multiplicities
     * as values.
     * 
     * @param ds the input symbol.
     * @return a map assigning to each component type the number of occurences.
     */
    public static Map<DelaneySymbol, Integer> componentMultiplicities(
			final DelaneySymbol ds) {
        final Map<DelaneySymbol, Integer> type2number =
        	new HashMap<DelaneySymbol, Integer>();
        final List idcs = new IndexList(ds);
        for (final Iterator reps = ds.orbitReps(idcs); reps.hasNext();) {
            final DelaneySymbol sub =
            	new Subsymbol(ds, idcs, reps.next()).canonical();
            if (type2number.containsKey(sub)) {
                type2number.put(sub, type2number .get(sub) + 1);
            } else {
                type2number.put(sub, 1);
            }
        }
        return type2number;
    }

    /**
     * Returns the list of distinct subcanonical forms for a given connected
     * symbol. A subcanonical form is obtained by assigning numbers to the
     * elements in the order they are visited by a standard traversal starting
     * from an arbitrary element.
     * 
     * @param ds the input symbol.
     * @return the list of subcanonical forms.
     */
    public static List<DSymbol> subCanonicalForms(final DelaneySymbol ds) {
        if (!ds.isConnected()) {
            throw new UnsupportedOperationException("symbol must be connected");
        }
        if (!ds.hasStandardIndexSet()) {
            throw new UnsupportedOperationException(
                    "symbol must have indices 0..dim");
        }

        final List<DSymbol> res = new LinkedList<DSymbol>();

        final int size = ds.size();
        final int dim = ds.dim();
        final List idcs = new IndexList(ds);

        final List reps = firstRepresentatives(ds);
        for (final Iterator iter = reps.iterator(); iter.hasNext();) {
            final Object seed = iter.next();
            final Traversal trav = new Traversal(ds, idcs, seed, true);

            // --- elements will be numbered in the order they appear
            final HashMap<Object, Integer> old2new =
            	new HashMap<Object, Integer>();

            // --- follow the traversal and assign the new numbers
            int nextE = 1;
            while (trav.hasNext()) {
                // --- retrieve the next edge
                final DSPair e = (DSPair) trav.next();
                final Object D = e.getElement();

                // --- determine a running number E for the target element D
                final Integer tmp = old2new.get(D);
                if (tmp == null) {
                    // --- element D is encountered for the first time
                    old2new.put(D, nextE);
                    ++nextE;
                }
            }

            // --- construct the new symbol
            int op[][] = new int[dim + 1][size + 1];
            int v[][] = new int[dim][size + 1];

            for (final Iterator elms = ds.elements(); elms.hasNext();) {
                final Object E = elms.next();
                final int D = old2new.get(E);
                for (int i = 0; i <= dim; ++i) {
                    op[i][D] = old2new.get(ds.op(i, E));
                    if (i < dim) {
                        v[i][D] = ds.v(i, i + 1, E);
                    }
                }
            }

            // --- add it to the list
            res.add(new DSymbol(op, v));
        }

        // --- finis
        return res;
    }

    /**
     * Takes a connected symbol and computes the first representative of each
     * equivalence class of its elements with respect to its automorphism group.
     * 
     * @param ds the symbol to use.
     * @return the list of first representatives.
     */
    public static List<Object> firstRepresentatives(final DelaneySymbol ds) {
        final Map map = mapToFirstRepresentatives(ds);
        final List<Object> res = new ArrayList<Object>();
        for (final Iterator elms = ds.elements(); elms.hasNext();) {
            final Object D = elms.next();
            if (D.equals(map.get(D))) {
                res.add(D);
            }
        }
        return res;
    }

    /**
     * Takes a connected symbol and returns a map that to each element assigns
     * the first representative of its equivalence class with respect to the
     * symbol's automorphism group.
     * 
     * @param ds the symbol to use.
     * @return the map from elements to first representatives.
     */
    public static Map<Object, Object> mapToFirstRepresentatives(
			final DelaneySymbol ds) {
        if (!ds.isConnected()) {
            throw new UnsupportedOperationException("symbol must be connected");
        }

        final Map<Object, Object> res = new HashMap<Object, Object>();
        final Iterator elms = ds.elements();
        if (elms.hasNext()) {
            final Object first = elms.next();
            final Partition classes = new Partition();
            while (elms.hasNext()) {
                final Object D = elms.next();
                if (classes.areEquivalent(first, D)) {
                    continue;
                }
                final Map morphism;
                try {
                    morphism = new DSMorphism(ds, ds, first, D);
                } catch (IllegalArgumentException ex) {
                    continue;
                }
                for (final Iterator iter = ds.elements(); iter.hasNext();) {
                    final Object E = iter.next();
                    classes.unite(E, morphism.get(E));
                }
            }

            for (final Iterator iter = ds.elements(); iter.hasNext();) {
                final Object D = iter.next();
                final Object E = classes.find(D);
                if (!res.containsKey(E)) {
                    res.put(D, D);
                    res.put(E, D);
                } else {
                    res.put(D, res.get(E));
                }
            }
        }
        return res;
    }

    /**
     * Hook for derived classes to specify additional deductions of a move.
     * 
     * @param ds the current symbol.
     * @param move the last move performed.
     * @return the list of deductions (may be empty) or null in case of a
     *         contradiction.
     */
    protected List<Move> getExtraDeductions(final DelaneySymbol ds,
			final Move move) {
		return new ArrayList<Move>();
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#checkMove(org.gavrog.joss.algorithms.BranchAndCut.Move)
	 */
	@Override
	protected Status checkMove(final Move move) {
        final Object D = ((CMove) move).element;
        final Object E = ((CMove) move).neighbor;
        final int d = this.dim;

        if (current.definesOp(d, D) || current.definesOp(d, E)) {
            if (current.definesOp(d, D) && current.op(d, D).equals(E)) {
                return Status.VOID;
            } else {
                log("#    found contradiction at " + D + "<-->" + E);
                return Status.ILLEGAL;
            }
        }
        return Status.OK;
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#deductions(org.gavrog.joss.algorithms.BranchAndCut.Move)
	 */
	@Override
	protected List<Move> deductions(final Move move) {
		final List<Move> res = new LinkedList<Move>();
        final Object D = ((CMove) move).element;
        final Object E = ((CMove) move).neighbor;
		final List<Move> extra = getExtraDeductions(this.current, move);
		if (extra != null) {
			res.addAll(extra);
		} else {
			//TODO in the old version, a null result signals a contradiction
		}
        for (int i = 0; i <= this.dim - 2; ++i) {
            final Object Di = this.current.op(i, D);
            final Object Ei = this.current.op(i, E);
            res.add(new CMove(Di, Ei, -1, -1));
        }
		return res;
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#isComplete()
	 */
	@Override
	protected boolean isComplete() {
		for (final Iterator iter = this.current.elements(); iter.hasNext();) {
			final Object D = iter.next();
			if (!this.current.definesOp(this.dim, D)) {
				return false;
			}
		}
		return true;
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#isValid()
	 */
	@Override
	protected boolean isValid() {
		// TODO Auto-generated method stub
		return false;
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#makeResult()
	 */
	@Override
	protected DSymbol makeResult() {
		// TODO Auto-generated method stub
		return null;
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#nextChoice(org.gavrog.joss.algorithms.BranchAndCut.Move)
	 */
	@Override
	protected Move nextChoice(Move previous) {
		// TODO Auto-generated method stub
		return null;
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#nextDecision(org.gavrog.joss.algorithms.BranchAndCut.Move)
	 */
	@Override
	protected Move nextDecision(Move previous) {
		// TODO Auto-generated method stub
		return null;
	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#performMove(org.gavrog.joss.algorithms.BranchAndCut.Move)
	 */
	@Override
	protected void performMove(Move move) {
		// TODO Auto-generated method stub

	}

	/* (non-Javadoc)
	 * @see org.gavrog.joss.algorithms.BranchAndCut#undoMove(org.gavrog.joss.algorithms.BranchAndCut.Move)
	 */
	@Override
	protected void undoMove(Move move) {
		// TODO Auto-generated method stub

	}

}
